Docker Network
â”‚
â”œâ”€â”€ main-backend (port 8080)
â”‚     â”œâ”€ Handles users, auth (JWT), DB (Postgres), Redis, mail worker
â”‚
â”œâ”€â”€ chat-service (Spring Boot WebSocket microservice, port 8081)
â”‚     â”œâ”€ Handles real-time connections & message delivery
â”‚     â”œâ”€ Validates JWT from main-backend
â”‚     â”œâ”€ Future: can persist messages, or send events via Redis
â”‚
â””â”€â”€ frontend (optional later)
      â”œâ”€ Connects via WebSocket to chat-service
      â”œâ”€ Auth header contains JWT from main-backend login

âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸

String chatId = getChatId(sender, receiver); // "user1_user2"
for (WebSocketSession s : chatRooms.get(chatId)) {
    if (s.isOpen()) {
        s.sendMessage(new TextMessage(payload));
    }
}
âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸âœˆï¸






      ğŸ§© Project Summary â€” Spring Boot Chat Microservice (P2P, JWT-based)
Architecture Overview

Youâ€™ll run a separate Spring Boot WebSocket microservice (chat-service) alongside your main backend (already running in Docker with Postgres, Redis, etc.).

The chat-service handles real-time messaging only.

The main backend continues to handle JWT authentication, user data, and (later) message persistence.

Docker Network:
â”œâ”€â”€ main-backend (8080): JWT auth, Postgres, Redis
â”œâ”€â”€ chat-service (8081): WebSocket + STOMP real-time chat
â””â”€â”€ frontend (optional): connects via JWT token in WebSocket URL

JWT Integration

The frontend connects like:

ws://chat-service:8081/ws/chat?token=<JWT>


The chat-service validates the token using the same secret/public key as the main backend.

Authenticated users can then send and receive messages.

WebSocket Setup

Uses Spring WebSocket + STOMP.

Endpoints:

/ws â†’ WebSocket handshake

/app â†’ app message destinations (client â†’ server)

/user/{id}/queue/messages â†’ private queue (server â†’ client)

Message flow:

Sender â†’ /app/private.send

Server â†’ /user/{receiver}/queue/messages

Session Handling

Each open tab/device = one WebSocket session.

By default, Spring delivers messages to all active sessions of that user.

You can track sessions using SessionConnectEvent and SessionDisconnectEvent.

You may enforce single-session login later if needed â€” not required now.

Persistence

(Deferred for now)

Offline message storage and history fetching will later be handled by the main backend.

Chat-service can forward undeliverable messages via REST API to store them in DB.

Next Steps for Implementation

Add dependencies in build.gradle:

spring-boot-starter-websocket

spring-boot-starter-security (for JWT parsing)

jjwt or java-jwt

Create:

WebSocketConfig.java â†’ STOMP setup

JwtHandshakeInterceptor.java â†’ validate JWT on connection

ChatController.java â†’ handle message routing

ChatMessage.java â†’ message model

Test locally using Postman or wscat to simulate chat.

âœ… Core Concept Recap
Feature	Handled By
Real-time chat	WebSocket microservice
Authentication	JWT (main backend)
Offline messages / history	(Later) main backend
Multiple devices	Supported â€” each = 1 session
Message routing	/app â†’ /user/queue via STOMP

This setup gives you:

ğŸ”’ Secure,